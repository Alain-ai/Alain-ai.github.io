<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Alain's Blog | Home - Java, Python, Machine Learning, LeetCode</title>
    <meta name="keywords" content="Java, Python, Machine Learning, LeetCode">
    <meta name="description" content="The personal site of Alain, MLer and programmer. I write about Java, Python, Machine Learning and my code on LeetCode Here.">
    <meta name="author" content="Alain">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="/static/favicon.ico" rel="shortcut icon">
    <link href="/static/css/bootstrap.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/css/font-awesome.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/google-code-prettify/prettify.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/css/application.css" rel="stylesheet" type="text/css" media="all">
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

</head>
<body>
     <div class="page-container">
     <div class="page-heading">
         <div class="page-brand">
             <h1><a href="/">Alain</a></h1>
             <h2><a href="/tags.html">Java Intermediate, Python Beginner, Machine Learning Fan</a></h2>

         </div>
         <div class="page-navbar">
             <div class="page-navbar-container">
                 <ul class="page-nav">
                     <li><a href="/">Home</a></li>
                     <!-- <li><a href="/about.html">About</a></li> -->
                     <li><a href="/categories.html">Categories</a></li>
                     <li><a href="/tags.html">Tags</a></li>
                     <li><a href="/archive.html">Archives</a></li>
                 </ul>
             </div>
         </div>
     </div>
     <div class="page-article">
         <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54880616-1', 'auto');
  ga('send', 'pageview');

</script>


<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-sort-list/">LeetCode | Sort List in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-sort-list/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Sort a linked list in O(n log n) time using constant space complexity.

Algorithm:
    merge sort

Note:
    can not get accepted sigh
'''


class Solution:
    # @param head, a ListNode
    # @return a ListNode
    def sortList(self, head):
        if not head or not head.next:
            return head
        p = pp = dummy = ListNode(0)
        dummy.next = head
        while p and pp and pp.next:
            p = p.next
            pp = pp.next.next
        p1, p2 = head, p.next
        p.next = None
        p1 = self.sortList(p1)
        p2 = self.sortList(p2)
        p = dummy = ListNode(0)
        dummy.next = p1
        while p1 and p2:
            if p1.val < p2.val:
                p.next = p1
                p1 = p1.next
            else:
                p.next = p2
                p2 = p2.next
            p = p.next
        if p1:
            p.next = p1
        if p2:
            p.next = p2
        return dummy.next
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-sort-list/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-simplify-path/">LeetCode | Simplify Path in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-simplify-path/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given an absolute path for a file (Unix-style), simplify it.

Algorithm:
    split + stack
'''


class Solution:
    # @param path, a string
    # @return a string
    def simplifyPath(self, path):
        metas = path.strip().split('/')
        stk = []
        for meta in metas:
            if not meta or meta == '.':
                continue
            elif meta == '..':
                if stk:
                    stk.pop()
            else:
                stk.append(meta)
        if not stk:
            return '/'
        res = ''
        for s in stk:
            res += '/' + s
        return res
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-simplify-path/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-search-insert-position/">LeetCode | Search Insert Position in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-search-insert-position/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.

Algorithm:
    binary search
    1. the lower bound finally returns the first index which holds the value no less than the target
    2. the upper bound finally returns the last index which holds the value no more than the target
    3. we use "1" here

Note:
    Corner cases:
    1. len(A) <= 1
    2. the insertion place is at the two sides
'''


class Solution:
    # @param A, a list of integers
    # @param target, an integer to be inserted
    # @return integer
    def searchInsert(self, A, target):

        if len(A) == 0:
            return 0
        i, j = 0, len(A) - 1
        while i <= j:
            m = (i+j) >> 1
            if A[m] == target:
                return m
            elif A[m] < target:
                i = m + 1
            else:
                j = m - 1
        return i
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-search-insert-position/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-search-for-a-range/">LeetCode | Search for a Range in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-search-for-a-range/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.

Algorithm:
    binary search
    1. the lower bound finally returns the first index which holds the value no less than the target
    2. the upper bound finally returns the last index which holds the value no more than the target

Note:
    Corner cases:
    1. len(A) <= 1
    2. the target is at the two ends
'''


class Solution:
    # @param A, a list of integers
    # @param target, an integer to be searched
    # @return a list of length 2, [index1, index2]
    def searchRange(self, A, target):
        found = False
        if len(A) == 0:
            return [-1, -1]
        i, j = 0, len(A) - 1
        while i <= j:
            m = (i+j) >> 1
            if A[m] == target:
                found = True
                j -= 1
            elif A[m] < target:
                i = m + 1
            else:
                j = m - 1
        low = i if found else -1
        i, j = 0, len(A) - 1
        while i <= j:
            m = (i + j) >> 1
            if A[m] == target:
                i += 1
            elif A[m] < target:
                i = m + 1
            else:
                j = m - 1
        high = j if found else -1
        return [low, high]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-search-for-a-range/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-remove-duplicates-from-sorted-array-ii/">LeetCode | Remove Duplicates from Sorted Array II in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-remove-duplicates-from-sorted-array-ii/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. What if duplicates are allowed at most twice?

Algorithm:
    ...
'''


class Solution:
    # @param A a list of integers
    # @return an integer
    def removeDuplicates(self, A):
        if len(A) == 0:
            return 0
        repeated, idx = False, 1
        for i in xrange(1, len(A)):
            if A[i-1] == A[i]:
                repeated = True
            else:
                if repeated:
                    A[idx] = A[i-1]
                    idx += 1
                    A[idx] = A[i]
                    idx += 1
                else:
                    A[idx] = A[i]
                    idx += 1
                repeated = False
        if repeated:
            A[idx] = A[-1]
            idx += 1
        return idx
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-remove-duplicates-from-sorted-array-ii/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-median-of-two-sorted-arrays/">LeetCode | Median of Two Sorted Arrays in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-median-of-two-sorted-arrays/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Algorithm:
    a variant of binary search
'''


class Solution:
    # @return a float
    def findMedianSortedArrays(self, A, B):
        if len(A) == len(B) == 0:
            return None
        ls = len(A) + len(B)
        if ls & 1:
            return self.find_smallest_k(A, B, 0, 0, ls/2+1)
        else:
            return (self.find_smallest_k(A, B, 0, 0, ls/2) + self.find_smallest_k(A, B, 0, 0, ls/2+1)) / 2.

    def find_smallest_k(self, A, B, sa, sb, kth):
        if len(A) > len(B):
            return self.find_smallest_k(B, A, sb, sa, kth)
        if sa == len(A):
            return B[sb+kth-1]
        if sb == len(B):
            return A[sa+kth-1]
        if kth == 1:
            return min(A[sa], B[sb])
        ca = min(kth/2, len(A) - sa)  # the number of elements "a" can contribute
        cb = kth - ca  # the number of elements "a" can contribute
        if A[sa + ca - 1] == B[sb + cb - 1]:
            return A[sa + ca - 1]
        elif A[sa + ca - 1] > B[sb + cb - 1]:  # B[sb:sb+cb] must be less than the kth element
            return self.find_smallest_k(A, B, sa, sb + cb, kth-cb)
        else:  # A[sa:sa+ca] must be less than the kth element
            return self.find_smallest_k(A, B, sa+ca, sb, kth-ca)
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-median-of-two-sorted-arrays/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-longest-palindromic-substring/">LeetCode | Longest Palindromic Substring in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-longest-palindromic-substring/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.

Algorithm:
    1. extend i to two ends
    2. extend i and i+1 to two ends
'''


class Solution:
    # @return a string
    def longestPalindrome(self, s):
        max_s = ''
        for i in xrange(len(s)):
            s1 = self.extend(s, i)
            if len(s1) > len(max_s):
                max_s = s1
            s2 = self.extend(s, i, i+1)
            if len(s2) > len(max_s):
                max_s = s2
        return max_s

    def extend(self, s, i, j=None):
        if j:
            while i >= 0 and j < len(s) and s[i] == s[j]:
                i, j = i - 1, j + 1
            return s[i+1:j]
        else:
            j, k = i - 1, i + 1
            while j >= 0 and k < len(s) and s[j] == s[k]:
                j, k = j - 1, k + 1
            return s[j+1:k]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-longest-palindromic-substring/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-interleaving-string/">LeetCode | Interleaving String in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-interleaving-string/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

Algorithm:
    whether s1[0:i] and s2[0:j] interleave and form s3[0:i+j]
    DP[i][j] = DP[i-1][j] if s3[0:i+j-1] == s1[i-1]
    DP[i][j] = DP[i][j-1] if s3[0:i+j-1] == s2[j-1]
'''


class Solution:
    # @return a boolean
    def isInterleave(self, s1, s2, s3):
        if len(s3) != len(s1) + len(s2):
            return False
        DP = [[False for itr in xrange(len(s2)+1)] for itr2 in xrange(len(s1)+1)]
        DP[0][0] = True
        for i in xrange(1, len(s2)+1):
            DP[0][i] = False if s3[i-1] != s2[i-1] else DP[0][i-1]
        for i in xrange(1, len(s1)+1):
            DP[i][0] = False if s3[i-1] != s1[i-1] else DP[i-1][0]
        for i in xrange(1, len(s1)+1):
            for j in xrange(1, len(s2)+1):
                if s3[i-1+j-1+1] == s1[i-1]:
                    DP[i][j] = DP[i-1][j]
                if not DP[i][j] and s3[i-1+j-1+1] == s2[j-1]:
                    DP[i][j] = DP[i][j-1]
        return DP[len(s1)][len(s2)]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-interleaving-string/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-insertion-sort-list/">LeetCode | Insertion Sort List in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-insertion-sort-list/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Sort a linked list using insertion sort.

Algorithm:
    ...

Note:
    Can not get accepted sigh...
'''


class Solution:
    # @param head, a ListNode
    # @return a ListNode
    def insertionSortList(self, head):
        p = dummy = ListNode(head.val)
        dummy.next = head
        while p.next:
            if p.next.val >= p.val:
                p = p.next
            else:
                tmp = p.next
                p.next = tmp.next
                pp = dummy
                while pp.next and pp != p:
                    if pp.next.val > tmp.val:
                        tmp.next = pp.next
                        pp.next = tmp
                        break
                    else:
                        pp = pp.next
        return dummy.next
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-insertion-sort-list/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-gas-station/">LeetCode | Gas Station in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-gas-station/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station\'s index if you can travel around the circuit once, otherwise return -1.

Note:
    The solution is guaranteed to be unique.

Algorithm:
    1. first get the left array
    2. start from some place where left > 0 denoted as i
    3. continue driving until "left_local" < 0 denoted as j
    4. start from j again because anywhere from i to j won\'t be better than i
'''


class Solution:
    # @param gas, a list of integers
    # @param cost, a list of integers
    # @return an integer
    def canCompleteCircuit(self, gas, cost):
        left = map(lambda x, y: x - y, gas, cost)
        i = 0
        if len(gas) == 1:
            return 0 if left[0] >= 0 else -1
        while i < len(gas):
            if left[i] <= 0:
                i += 1
                continue
            j, left_local = 1, left[i]
            while j < len(gas):
                k = (i + j) % len(gas)
                left_local += left[k]
                if left_local < 0:
                    i = i + j
                    break
                j += 1
            if j == len(gas):
                return i
            else:
                i += 1
        return -1
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-gas-station/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-first-missing-positive/">LeetCode | First Missing Positive in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-first-missing-positive/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given an unsorted integer array, find the first missing positive integer. For example,
    Given [1,2,0] return 3, and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space.

Algorithm:
    1. if A[i] <= 0, ignore
    2. if A[i] > len(A), ignore
    3. otherwise try to let A[i] = i + 1 by exchanging

Note:
    Corner cases:
        1. len(A) == 0
        2. A = [1]
        3. A = [-1]
        4. A = [2]
'''


class Solution:
    # @param A, a list of integers
    # @return an integer
    def firstMissingPositive(self, A):
        i = 0
        while i < len(A):
            if 1 <= A[i] <= len(A) and A[A[i]-1] != A[i]:
                A[A[i]-1], A[i] = A[i], A[A[i]-1]
            else:
                i += 1
        i = 0
        while i < len(A):
            if A[i] != i+1:
                return i+1
            i += 1
        return i+1
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-first-missing-positive/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-edit-distance/">LeetCode | Edit Distance in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-edit-distance/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word:
    a) Insert a character
    b) Delete a character
    c) Replace a character

Algorithm:
    DP
    DP[i][j] = min(DP[i-1][j]+1, DP[i][j-1]+1, (DP[i-1][j-1] + (0 if word1[i-1] == word2[j-1] else 1)))
'''


class Solution:
    # @return an integer
    def minDistance(self, word1, word2):
        l1, l2 = len(word1), len(word2)
        DP = [[0 for itr in xrange(l2+1)] for itr2 in xrange(l1+1)]
        for i in xrange(1, l2+1):
            DP[0][i] = DP[0][i-1] + 1
        for i in xrange(1, l1+1):
            DP[i][0] = DP[i-1][0] + 1
        for i in xrange(1, l1+1):
            for j in xrange(1, l2+1):
                DP[i][j] = min(DP[i-1][j]+1, DP[i][j-1]+1, (DP[i-1][j-1] + (0 if word1[i-1] == word2[j-1] else 1)))
        return DP[l1][l2]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-edit-distance/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-decode-ways/">LeetCode | Decode Ways in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-decode-ways/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    A message containing letters from A-Z is being encoded to numbers using the following mapping:

    "A" -> 1
    "B" -> 2
    ...
    "Z" -> 26
    Given an encoded message containing digits, determine the total number of ways to decode it.

Algorithm:
    DP, a variant of Fibo
    DP[i] = DP[i] + DP[i-1] if 1 <= s[i] <= 9
    DP[i] = DP[i] + DP[i-2]  if 10 <= s[i-1:i+1] <= 26
'''


class Solution:
    # @param s, a string
    # @return an integer
    def numDecodings(self, s):
        if len(s) == 0:
            return 0
        check = set([str(itr) for itr in xrange(10, 27)])
        DP = [1 if 1 <= int(s[0]) <= 9 else 0] + [0 for itr in xrange(len(s)-1)]
        for i in xrange(1, len(s)):
            DP[i] = DP[i-1] if 1 <= int(s[i]) <= 9 else 0
            if s[i-1:i+1] in check:
                DP[i] += DP[i-2] if i >= 2 else 1
        return DP[-1]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-decode-ways/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-combination-sum-ii/">LeetCode | Combination Sum II in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-combination-sum-ii/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination.

Note:
    1. All numbers (including target) will be positive integers.
    2. Elements in a combination (a1, a2, ... , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ ... ≤ ak).
    3. The solution set must not contain duplicate combinations.

Algorithm:
    DFS
    when candidates[i] == candidates[i-1], ignore candidates[i] to avoid duplications
'''


class Solution:
    # @param candidates, a list of integers
    # @param target, integer
    # @return a list of lists of integers
    def combinationSum2(self, candidates, target):
        res = []
        candidates.sort()
        self.combinationSum2_rec(candidates, target, 0, [], res)
        return res

    def combinationSum2_rec(self, candidates, target, start, stk, res):
        if target == 0:
            res.append(stk)
        if target > 0:
            for i in xrange(start, len(candidates)):
                if i > start and candidates[i] == candidates[i-1]:
                    continue
                self.combinationSum2_rec(candidates, target-candidates[i], i+1, stk+[candidates[i]], res)
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-combination-sum-ii/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-combination-sum/">LeetCode | Combination Sum in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-combination-sum/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times.

Note:
    1. All numbers (including target) will be positive integers.
    2. Elements in a combination (a1, a2, ... , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ ... ≤ ak).
    3. The solution set must not contain duplicate combinations.

Algorithm:
    DFS
'''


class Solution:
    # @param candidates, a list of integers
    # @param target, integer
    # @return a list of lists of integers
    def combinationSum(self, candidates, target):
        res = []
        candidates.sort()
        self.combinationSum_rec(candidates, target, 0, [], res)
        return res

    def combinationSum_rec(self, candidates, target, start, stk, res):
        if target == 0:
            res.append(stk)
        if target > 0:
            for i in xrange(start, len(candidates)):
                self.combinationSum_rec(candidates, target-candidates[i], i, stk+[candidates[i]], res)
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-combination-sum/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-binary-tree-maximum-path-sum/">LeetCode | Binary Tree Maximum Path Sum in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-binary-tree-maximum-path-sum/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a binary tree, find the maximum path sum. The path may start and end at any node in the tree.

Algorithm:
    1. "maxPathSum_rec(node)" returns the path with maximal sum which starts at "node"
    2. "max_local" is the maximal sum of the path which passes by the specific node(root)
    3. we would like to find the max of all "max_local"s among all nodes
'''


class Solution:
    # @param root, a tree node
    # @return an integer
    def maxPathSum(self, root):
        res = [-(1<<31)]
        self.maxPathSum_rec(root, res)
        return res[0]

    def maxPathSum_rec(self, root, res):
        if not root:
            return 0
        max_left = self.maxPathSum_rec(root.left, res)
        max_right = self.maxPathSum_rec(root.right, res)
        max_local = max(max_left, 0) + max(max_right, 0) + root.val
        res[0] = max(res[0], max_local)
        return max(max_left, max_right, 0) + root.val
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-binary-tree-maximum-path-sum/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-binary-tree-inorder-traversal/">LeetCode | Binary Tree Inorder Traversal in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-binary-tree-inorder-traversal/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a binary tree, return the inorder traversal of its nodes\' values.

Algorithm:
    Morris traversal
'''


class Solution:
    # @param root, a tree node
    # @return a list of integers
    def inorderTraversal(self, root):
        res = []
        cur = root
        while cur:
            if not cur.left:
                res.append(cur.val)
                cur = cur.right
            else:
                tmp = cur.left
                while tmp.right and tmp.right != cur:
                    tmp = tmp.right
                if not tmp.right:
                    tmp.right = cur
                    cur = cur.left
                else:
                    tmp.right = None
                    res.append(cur.val)
                    cur = cur.right
        return res
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-binary-tree-inorder-traversal/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-design-pattern-singleton/">Singleton</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-design-pattern-singleton/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#design_pattern-ref">design_pattern</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Java-ref">Java</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>


<p>Singleton Pattern requires there is only one instance of a class allowed. There exist three obvious features in a singleton class.</p>

<ol>
<li>private construtor</li>
<li>private static reference</li>
<li>public static "getInstance" method</li>
</ol>


<p>Here is a basic example that works in regular environment.</p>

<h2>Example 1</h2>

<pre>
public class A {

    private static A a;

    private A() {}

    public static A getInstance() {
        if (a == null) {
            a = new A();
        }
        return a;
    }
}
</pre>


<p>Note that example 1 only works at the single thread setting. When it comes to the multi-thread environment, more than one instance still can be created. Thus we try to improve example 1 to fit the multi-thread situation.</p>

<h2>Example 2</h2>

<pre>
public class A {

    private static A a;

    private A() {}

    private static final Object obj = new Object();

    public static A getInstance() {
        synchronized (obj) {
            if (a == null) {
                a = new A();
            }
        }
        return a;
    }
}
</pre>


<p>In example 2, every execution of "getInstance" will add a locker on "obj", which could be inefficient. Can we do better? We need a mechanism to let a statement or a block of statements run only once. Java really provides us something like this. It's "static block". The following example shows how it looks like.</p>

<h2>Exmaple 3</h2>

<pre>
public class A {

    static{
        a = new A();
    }

    private static A a;

    private A() {}

    public static A getInstance() {
        return a;
    }
}
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-design-pattern-singleton/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-design-pattern-decorator/">Decorator</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-design-pattern-decorator/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#design_pattern-ref">design_pattern</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Java-ref">Java</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>


<p>Let's introduce the requirement for importing decorator design pattern. Say we want to read off from four types of input:</p>

<pre><code>1. InputStream
2. File
3. char array
4. String
</code></pre>

<p>We have a abstract class Reader to outline some basic methods like read, close and skip.</p>

<pre>
public abstract class Reader implements Readable, Closeable {

    protected Object lock;

    protected Reader(Object lock) {
        if (lock == null) {
            throw new NullPointerException();
        }
        this.lock = lock;
     }
 }
</pre>


<p>Then we create four classes which extend Reader. They get direct touch with those four types of input. They are :</p>

<pre><code>1. InputSteamReader
2. FileReader
3. CharArrayReader
4. StringReader
</code></pre>

<p>Additionally, we want other two Readers which provide more efficient methods of reading than those four ground Reader. They are BufferedReader and LineNumberReader. With the combination of the two high level Readers and four low level Readers, we've got 8 classes. They are:</p>

<pre><code>1. BufferedInputSteamReader
2. BufferedFileReader
3. ...
4. ...
5. LineNumberInputSteamReader
6. LineNumberFileReader
7. ...
8. ...
</code></pre>

<p>With more input types and more high level Readers, we'll create too many Readers(13), which is called class explosion. So, it's a good place to introduce decorator design pattern.</p>

<p>For example, we have created a low level Reader "InputSteamReader" to read from standard input(InputStream System.in).</p>

<pre>
public class InputStreamReader extends Reader {

    private final StreamDecoder sd;

    public InputStreamReader(InputStream in) {
       super(in);
       try {
           sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // ## check lock object
       } catch (UnsupportedEncodingException e) {
           // The default encoding should always be available
           throw new Error(e);
       }
    }
}
</pre>


<p>We don't have to create a class like BufferedInputSteamReader, and we just need create a class called BufferedReader which will wrap a Reader(InputSteamReader here) and provide its own ways to read off. Now we say BufferedReader decorates InputSteamReader.</p>

<pre>
public class BufferedReader extends Reader {

    private Reader in;

    public BufferedReader(Reader in, int sz) {
       super(in);
       if (sz <= 0)
           throw new IllegalArgumentException("Buffer size <= 0");
       this.in = in;
       cb = new char[sz];
       nextChar = nChars = 0;
    }
}
</pre>


<p>When BufferedReader visit to input directly, this.in will do the real job. In this way, BufferedReader does not have to care about how to read from input and just need assemble output from this.in and provide highly efficient reading methods.</p>

<p>After applying decorator design pattern, we will get 7 Readers totally.</p>

    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-design-pattern-decorator/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-palindrome-partitioning-ii/">LeetCode | Palindrome Partitioning II in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-palindrome-partitioning-ii/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.

Algorithm:
    DP
    fist get the valid palindrome table for more efficient queries
    DP[i] = min(DP[j]+1), 0 <= j <= i-1
'''


class Solution:
    # @param s, a string
    # @return an integer
    def minCut(self, s):
        if not s:
            return 0
        l = len(s)
        table = [[True if itr2 == itr else False for itr2 in xrange(l)] for itr in xrange(l)]
        for i in xrange(l-2, -1, -1):
            for j in xrange(i+1, l):
                if s[i] == s[j]:
                    table[i][j] = table[i+1][j-1] if i+1 <= j-1 else True
        DP = [0 for itr in xrange(l)]
        for i in xrange(1, l):
            DP[i] = DP[i-1] + 1
            for j in xrange(i+1):
                if table[j][i]:
                    DP[i] = min(DP[i], DP[j-1]+1 if j-1 >= 0 else 0)
        return DP[-1]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-palindrome-partitioning-ii/">more &rarr;</a>
        </div>
    </div>
</div>


<div class="page-pagination">
    <ul class="pagination">
        <li><span>Navi:</span></li>
    
    
    
            
    
    
            
    
        <li><a href="/">newest</a></li>
    
    
        <li><a href="/page4">&larr;</a></li>
    
    
    
    
    
        
        <li><a href="/">1</a></li>
        
    
    
    
    
        <li><a href="/page2">2</a></li>
    
    
    
    
    
        <li><a href="/page3">3</a></li>
    
    
    
    
    
        <li><a href="/page4">4</a></li>
    
    
    
    
    
        <li><a href="/page5" class="active">5</a></li>
    
    
    
    
    
        <li><a href="/page6">6</a></li>
    
    
    
    
    
        <li><a href="/page7">7</a></li>
    
    
    
    
    
        <li><a href="/page8">8</a></li>
    
    
    
    
    
        <li><a class="next" href="/page6">&rarr;</a></li>
    
    <!--  -->

    <!--  -->
    <li><a href="/page8">oldest</a></li>
    <li><span>149</span></li>
    </ul>
</div>

     </div>
     <div class="page-footer">
         <span>
             Powered by <a href="https://github.com/mojombo/jekyll">Jekyll</a>
             | Hosted by <a href="http://github.com">Github.com</a>
             | <span class="page-generator-time">11/03/2014 </span>
         </span>
     </div>
     </div>
     <script src="/static/js/bootstrap.js" type="text/javascript"></script>
     <script src="/static/google-code-prettify/prettify.js" type="text/javascript"></script>
     <script type="text/javascript">
        $(document).ready(function() {
            $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto');
            prettyPrint();
        });
     </script>
     <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54880616-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>
