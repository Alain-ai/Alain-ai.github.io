<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Alain's Blog | Home - Java, Python, Machine Learning, LeetCode</title>
    <meta name="keywords" content="Java, Python, Machine Learning, LeetCode">
    <meta name="description" content="The personal site of Alain, MLer and programmer. I write about Java, Python, Machine Learning and my code on LeetCode Here.">
    <meta name="author" content="Alain">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="/static/favicon.ico" rel="shortcut icon">
    <link href="/static/css/bootstrap.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/css/font-awesome.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/google-code-prettify/prettify.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/css/application.css" rel="stylesheet" type="text/css" media="all">
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

</head>
<body>
     <div class="page-container">
     <div class="page-heading">
         <div class="page-brand">
             <h1><a href="/">Alain</a></h1>
             <h2><a href="/tags.html">Java Intermediate, Python Beginner, Machine Learning Fan</a></h2>

         </div>
         <div class="page-navbar">
             <div class="page-navbar-container">
                 <ul class="page-nav">
                     <li><a href="/">Home</a></li>
                     <!-- <li><a href="/about.html">About</a></li> -->
                     <li><a href="/categories.html">Categories</a></li>
                     <li><a href="/tags.html">Tags</a></li>
                     <li><a href="/archive.html">Archives</a></li>
                 </ul>
             </div>
         </div>
     </div>
     <div class="page-article">
         <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56332595-1', 'auto');
  ga('send', 'pageview');

</script>



<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-multiply-strings/">LeetCode | Multiply Strings  in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-multiply-strings/">09/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX","output/HTML-CSS"],
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
TeX: { equationNumbers: { autoNumber: "AMS" }, extensions: ["AMSmath.js", "AMSsymbols.js","noErrors.js","noUndefined.js"]}
});
</script>




<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>




<pre>
'''
Question: Given two numbers represented as strings, return multiplication of the numbers as a string. The numbers can be arbitrarily large and are non-negative.

Algorithm: To get the ith number,
    1. iterate j and k from num1 and num2 such that i == j
    2. sum over all num1[j] * num2[k] based on possible combinations of j and k
    3. ith number is sum % 10, carry is sum / 10
'''


class Solution:
    # \@param num1, a string
    # \@param num2, a string
    # \@return a string
    def multiply(self, num1, num2):
        num1 = num1[::-1]
        num2 = num2[::-1]
        l1, l2 = len(num1), len(num2)
        carry = 0
        res = []
        for i in xrange(l1+l2-1):
            tmp = carry
            for j in xrange(l1):
                k = i - j
                if 0 <= k < l2:
                    tmp += int(num1[j]) * int(num2[k])
            res.append(str(tmp % 10))
            carry = tmp / 10
        if carry:
            res += list(str(carry)[::-1])
        while len(res) > 1 and res[-1] == '0':
            res.pop()
        return ''.join(res)[::-1]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-multiply-strings/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-maximum-subarray/">LeetCode | Maximum Subarray in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-maximum-subarray/">09/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX","output/HTML-CSS"],
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
TeX: { equationNumbers: { autoNumber: "AMS" }, extensions: ["AMSmath.js", "AMSsymbols.js","noErrors.js","noUndefined.js"]}
});
</script>




<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>




<pre>
'''
Question:
    Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [−2,1,−3,4,−1,2,1,−5,4], the contiguous subarray [4,−1,2,1] has the largest sum = 6. Try divide and conquer approach.

Note:
    divide and conquer temporarily not accepted

Algorithm:
    1. divide and conquer, for each execution, get the following three results
        1. maximum subarray result exactly starting from the 1st element
        2. maximum subarray result exactly ending up with the last element
        3. maximum subarray result can start or end anywhere
    2. DP
        to see whether DP[i-1] will contribute, DP[i] = max(DP[i-1] + A[i], A[i])
'''


class Solution:
    # @param A, a list of integers
    # @return an integer
    def maxSubArray(self, A):
        return self.maxSubArray_rec(A, 0, len(A) - 1)[2]

    def maxSubArray_rec(self, A, start, end):
        if end == start:
            return [A[start]] * 3
        mid = (start + end) >> 1
        max_left_left, max_left_right, res_left = self.maxSubArray_rec(A, start, mid)
        max_right_left, max_right_right, res_right = self.maxSubArray_rec(A, mid+1, end)
        res_local = max(max_left_right+max_right_left, res_left, res_right)
        max_left, cum_left = A[0], [A[0]]
        for i in xrange(start, end+1):
            cum_left.append(cum_left[-1] + A[i])
            max_left = max(max_left, cum_left[-1])
        max_right, cum_right = A[-1], [A[-1]]
        for i in xrange(end-2, start-1, -1):
            cum_right.append(cum_right[-1] + A[i])
            max_right = max(max_right, cum_right[-1])
        return max_left, max_right, res_local

    # @param A, a list of integers
    # @return an integer
    def maxSubArray(self, A):
        DP = [A[0]]
        for i in xrange(1, len(A)):
            DP.append(max(DP[-1] + A[i], A[i]))
        return max(DP)
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-maximum-subarray/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-permutations-ii/">LeetCode | Permutations II in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-permutations-ii/">09/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question: Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example, [1,1,2] have the following unique permutations: [1,1,2], [1,2,1], and [2,1,1].

Algorithm: DFS, deduplicate when num[i] == num[i+1] after one execution
'''


class Solution:
    # @param num, a list of integer
    # @return a list of lists of integers
    def permuteUnique(self, num):
        num.sort()
        res = []
        visited = [False for itr in xrange(len(num))]
        self.permuteUnique_rec(num, 0, visited, [], res)
        return res

    def permuteUnique_rec(self, num, level, visited, stk, res):
        if level == len(num):
            res.append(stk)
        else:
            i = 0
            while i < len(num):
                if not visited[i]:
                    visited[i] = True
                    self.permuteUnique_rec(num, level+1, visited, stk+[num[i]], res)
                    visited[i] = False
                    while i < len(num) - 1 and num[i] == num[i+1]:
                        i += 1
                i += 1
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-permutations-ii/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-permutations/">LeetCode | Permutations in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-permutations/">09/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question: Given a collection of numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].

Algorithm: DFS
'''


class Solution:
    # @param num, a list of integer
    # @return a list of lists of integers
    def permute(self, num):
        num.sort()
        num.reverse()
        res = []
        visited = [False for itr in xrange(len(num))]
        self.permute_rec(num, 0, visited, [], res)
        return res

    def permute_rec(self, num, level, visited, stk, res):
        if level == len(num):
            res.append(stk)
        for i in xrange(len(num)):
            if not visited[i]:
                visited[i] = True
                self.permute_rec(num, level+1, visited, stk+[num[i]], res)
                visited[i] = False


    def permute(self, num):
        num.reverse()
        return [item for item in self.permute_rec(num)]

    def permute_rec(self, num):
        if len(num) == 1:
            yield num
        else:
            n = [num.pop()]
            for p in self.permute_rec(num):
                for i in xrange(len(p) + 1):
                    yield p[:i] + n + p[i:]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-permutations/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-shallow_copy/">Shallow & Deep Copy</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-shallow_copy/">09/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#language-ref">language</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>


<h2>Shallow Copy</h2>

<h3>Operaitons</h3>

<p>In python, an operation of shallow copy is as follows:</p>

<pre>
a = [...]
b = a[:]
b = list(a)
###########
a = {...}
b = dict(a)
###########
import copy
b = copy.copy(a)
</pre>


<h3>Principles</h3>

<p>For a compound structure like list, dict or even user-define class, the shallow copy will just go through the first level in the structure. Specifically, it iterates over all fields in that structure, if a field is a simple structure(like an integer), a copy of the value will be made; on the other hand, if a field is a compound structure, only the reference is going to be copyed.</p>

<h3>Example</h3>

<p>Here is an example to illustrate.</p>

<pre>
l1 = [1, [2,3], [4,5]]
l2 = l1[:] # l2 = list(l1) is identical
l2[0] = 6
print l1 # [1, [2,3], [4,5]]
print l2 # [6, [2,3], [4,5]]
l2[1] = [7, 8]
print l1 # [1, [2,3], [4,5]]
print l2 # [6, [7,8], [4,5]]
# the 2nd reference in l2 that was pointing to [2,3] is now to [7,8], [2,3] in l1 remains
l2[2][0] = 9
print l1 # [1, [2,3], [9,5]]
print l2 # [6, [7,8], [9,5]]
# 3rd reference in l1 and l2 was pointing to the same memory, [4,5], then the memory gets change to [9,5], l1 is affected
</pre>


<h2>Deep Copy</h2>

<h3>Operaitons</h3>

<p>In python, an operation of shallow copy is as follows:</p>

<pre>
import copy
b = copy.deepcopy(a)
</pre>


<h3>Principles</h3>

<p>For a compound structure, the deep copy will go throught all the way to the bottom level of the structure and construct a new compound object and then, recursively, inserts copies into it of the objects found in the original.</p>

<h3>Example</h3>

<p>Here is an example to illustrate.</p>

<pre>
import copy
l1 = [1, [2,3], [4,5]]
l2 = copy.deepcopy(l1)
l2[0] = 6
print l1 # [1, [2,3], [4,5]]
print l2 # [6, [2,3], [4,5]]
l2[1] = [7, 8]
print l1 # [1, [2,3], [4,5]]
print l2 # [6, [7,8], [4,5]]
l2[2][0] = 9
print l1 # [1, [2,3], [4,5]]
print l2 # [6, [7,8], [9,5]]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-shallow_copy/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-pass-parameter/">Pass Parameters to A Function</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-pass-parameter/">09/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#language-ref">language</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Java-ref">Java</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>


<p>As we know, in java, a primitive-type variable is passed to a function by value while a Object-type variable is passed by its reference(i.e, the address to the memory where the real variable is stored).</p>

<p>But it should be kept in mind that the reference will never be passed back to the caller. We can just think this as a copy of reference is passed to the called method.</p>

<p>If the parameter alters to refer to other object in the called method, the corresponding variable(the block of memory) in the caller won't be affected. However, the memory which the parameter is pointing to gets changed in the called method, it will affect the world outside.</p>

<p>Here is an example to illustrate this.</p>

<pre>
    class TryReferncenPassBack{  // some code we are not caring about this moment  
        int i;
    }

    class Test{

        public static void main(String [] args){
            TryReferncenPassBack t = new TryReferncenPassBack();
            t.i = 1;
            System.out.println(t.toString());
            System.out.println(t.i);
            method1(t);
            System.out.println(t.toString());
            System.out.println(t.i);
        }

        public static void method1(TryReferncenPassBack t){
            t.i = 2;
            t = new TryReferncenPassBack();
            System.out.println(t.toString());
            t.i = 3;
        }
    }
</pre>


<p>Result:</p>

<pre>
    TryReferncenPassBack@510bfe2c
    1
    TryReferncenPassBack@6a5c2445 // point to the new object
    TryReferncenPassBack@510bfe2c // after getting back, the reference still remains
    2 // the original memory gets changed at line 16 instead of line 19
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-pass-parameter/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-sklearn/">BaseEstimator in Scikit-Learn</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-sklearn/">09/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#machine_learning-ref">machine_learning</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Machine_Learning-ref">Machine_Learning</a>
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>


<h2>How it looks like</h2>

<p>Very simaple, just looks like as follows:</p>

<pre>
class BaseEstimator(object):

    @classmethod
    def _get_param_names(cls):

    def get_params(self, deep=True):

    def set_params(self, **params):

    def __repr__(self):
</pre>


<p>The existing four methods are mainly responsible for recognizing the names of paremeters and printing. However, just making use of these four methods, we are able to simplify our work a lot.</p>

<h2>How can we use it</h2>

<p>In order to use the class, the first thing comes to our minds is inheritance. After we make our individual estimators which inherits from the BaseEstimator, we are allowed to pass our own estimators to whatever methods provided by scikit-learn only if they take BaseEstimator as a parameter.</p>

<p>A quick example is sklearn.grid_search.GridSearchCV. Its signature is as</p>

<pre>
sklearn.grid_search.GridSearchCV(estimator, param_grid, scoring=None, loss_func=None, score_func=None, fit_params=None, n_jobs=1, iid=True, refit=True, cv=None, verbose=0, pre_dispatch='2*n_jobs')
</pre>


<p>As we see, we can pass our the estimators to the 1st parameter. Then we could take advantage of GridSearchCV to performe cross-validation with plenty of options rather than write program to do it. An additional requirement is that our estimators will need to implement fit(X, y) and predict(y).</p>

<h2>An Example</h2>

<p>Here is a concrete examples. Say we are going to implement a series of classifiers and run experiments on these.</p>

<p>First we boil down the common features of these classifiers, and make up a common parent called Estimator. Then we also have to let Estimator inherit from BaseEstimator so as to obtain the aforementioned sugar.</p>

<p>Then for each classifier we want to make, take Estimator as base class and implement its own "fit" and "predict" methods.</p>

<p>Say we'd like to make up a Logistic Regression classifier in this way. The mini-batch gradient descent has been used to optimize the model with a selective stepsize in every iteration epoch. The code looks like this.</p>

<pre>
class Estimator(sb.BaseEstimator):
    def common_method(**args):

class LogisticRegression(Estimator):
    def __init__(self, lamb=1., T=5000):
        self.lamb = lamb
        self.w = None
        self.T = T

    def predict(self, X_test):
        s = X_test.dot(self.w).ravel()
        s[np.where(s >= 0)[0]] = 1
        s[np.where(s < 0)[0]] = 0
        return s

    def fit(self, X_train, y_train):
        w = np.zeros(X_train.shape[1], dtype=np.float64)
        rand_idx = numpy.random.permutation(X_train.shape[0])
        avg_T, it = 250, 0

        ########################
        # plt.axis([0, self.T/avg_T + 1, 1000, 5000])
        # plt.ion()
        # plt.show()
        # p_i = 0
        ########################

        w = np.zeros(X_train.shape[1], dtype=np.float64)
        mean_pre, mean_cur = 0, 0
        obj = self.obj_func_lg(w, (X_train, y_train))
        objs = [obj]
        # objs = []
        rand_i = 0
        while it < self.T:
            eta = 1./(math.sqrt(it) + 1.)
            # eta = 1./(it + 1)
            # print 'iter ' + str(it)
            rand_i = rand_i % rand_idx.size
            mini_batch = rand_idx[rand_i:min(rand_i+10, len(rand_idx))]
            rand_i += 10
            x_rand = X_train[mini_batch, :].reshape((mini_batch.size, X_train.shape[1]))
            y_rand = y_train[mini_batch].reshape(mini_batch.size)
            g = self.gradient_lg(w, (x_rand, y_rand))
            w = w - eta * g.ravel()
            # obj = self.obj_func_lg(w, (X_train, y_train))
            # objs.append(obj)
            # if len(objs) == avg_T:
            #     mean_pre = mean_cur
            #     mean_cur = np.mean(objs)
            #
            #     ################################
            #     # plt.scatter(p_i, mean_cur)
            #     # p_i += 1
            #     # plt.draw()
            #     ################################
            #     objs = []
            #     if abs(mean_cur - mean_pre) < 1e-5:
            #         break
            it += 1
        self.w = w

    def obj_func_lg(self, w, *args):
        X, y = args[0], args[1]
        s = self.sigmoid(X, w)
        obj = self.lamb * .5 * (np.linalg.norm(w)**2)
        obj -= y.T.dot(np.log(s)) + (1. - y).T.dot(np.log(1. - s))
        return obj

    def gradient_lg(self, w, *args):
        X, y = args[0], args[1]
        s = self.sigmoid(X, w)
        g = X.T.dot((s - y)) + self.lamb * w
        return g.ravel()

    def sigmoid(X, w):
        s = 1. / (1. + np.exp(-1. * (X.dot(w))))
        return s.ravel()
</pre>


<p>Then we can performe cross-validation very easily like:</p>

<pre>
def lg_run(X, y, X_test, y_test):
    tuned_parameters = [{'lamb': [5.**i for i in xrange(-5, 5)]}]
    clf = sklearn.grid_search.GridSearchCV(LogisticRegression(fit_sel=2), tuned_parameters, cv=5, scoring='accuracy')
    clf.fit(X, y.ravel())
    print("Best parameters set found on development set:")
    print(clf.best_estimator_)
    clf_best = clf.best_estimator_
    y_pred = clf_best.predict(X_test)
    clf_best.stats_pred(y_pred, y_test)
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-sklearn/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-hashcode/">Hash Function</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-hashcode/">09/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#language-ref">language</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Java-ref">Java</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>


<h2>Many</h2>

<p>Hash function for String and other classes that have multiple variables such as List is defined recursively. However, they are not completely the same.</p>

<h2>String hash</h2>

<p>The code for String's hash function is shown as following:</p>

<pre>
  public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
      char val[] = value;
      for (int i = 0; i < value.length; i++) {
        h = 31 * h + val[i];
      }
      hash = h;
    }
     return h;
  }
</pre>


<p>The computational strategy is
$$s[0]*31^{(n-1)} + s[1]*31^{(n-2)} + ... + s[n-1],$$ where $s$ is the underlying char array of the String object. $s[i]$ is the corresponding char value.
We are also able to find out that the hash value for a String object is going to be calculated and <strong>stored only once</strong>.</p>

<h2>List hash</h2>

<p>Then the code for List's hash function is followed as:</p>

<pre>
  public int hashCode() {
    int hashCode = 1;
    for (E e : this)
      hashCode = 31\*hashCode + (e==null ? 0 : e.hashCode());
  return hashCode;
  }

</pre>


<p>It is defined recursively as
$$31^{n} + v_0*31^{(n-1)} + v_1*31^{(n-2)} + ... + v_{n-1},$$
 where $v_0, v_1, ..v_{n-1}$ are the variables. Without having the property of immutability of String, $v_1, v_2, ...v_{n-1}$ might change during running time. Thus at each time when hash function is called, the hash value will be <strong>recalculated</strong> as above.</p>

<h2>Array hash</h2>

<p>How about Array?
Let's boil down some essence from the following code.</p>

<pre>
    Integer [] is1 = new Integer[]{1};
    Integer [] is2 = new Integer[]{1};
    ArrayList<Integer> ls1 = new ArrayList<Integer>(Arrays.asList(is1));
    ArrayList<Integer> ls2 = new ArrayList<Integer>();
    ls2.add(1);
    System.out.println(is1.hashCode());
    System.out.println(is2.hashCode());
    System.out.println(Arrays.hashCode(is1));
    System.out.println(ls1.hashCode());
    System.out.println(ls2.hashCode());
</pre>


<p>The result is as</p>

<ul>
<li>481088980</li>
<li>386555905</li>
<li>32</li>
<li>32</li>
<li>32</li>
</ul>


<p>The reason why two random number "481088980" and "386555905" show up is that actually the native Object's hash function has been called. "Native" represents the implementation involves with the platform. A standard way to obtain the hash value of a array is Arrays.hashCode(), which looks like</p>

<pre>
public static int hashCode(Object a[]) {
  if (a == null)
    return 0;
  int result = 1;
  for (Object element : a)
    result = 31 * result + (element == null ? 0 : element.hashCode());
  return result;
}
</pre>


<p>It's easy to know hash functions for List and Array actually encodes the same idea to compute hash value.
32 follows from $31<sup>1</sup> + 1 * 31<sup>0</sup> = 32$ for "is1", "ls1" and "ls2".</p>

    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-hashcode/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-bloom-filter/">Bloom Filter</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-bloom-filter/">09/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#algorithm-ref">algorithm</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Other-ref">Other</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>


<h2>Limitation</h2>

<p>Bloom Filter does not support deletion operation
deletion operation might affect other objects</p>

<h2>False Positive</h2>

<p>Bloom Filter might have false positive
all slots that the new object is going to set have been already 1
thus, Bloom Filter will think this new object has already been seen</p>

<h2>Parameters</h2>

<p>We have several parameters for this algorithm</p>

<ul>
<li>n: number of bits available</li>
<li>S: number of objects to be stored</li>
<li>k: number of hash function to be used</li>
<li>c: number of bits for per object</li>
<li>where n = S * c</li>
</ul>


<h2>Why it works</h2>

<p>Consider the totally random situation, the probability of some slot to be 1 after S objects have been inserted into</p>

<ul>
<li>for one object and one hash function, the probability to be 0 is $(1-\frac{1}{n})$</li>
<li>after S objects have been inserted and each of which uses k hash functions, the probability to be 0 is
$(1-\frac{1}{n})^{k*S}$</li>
<li>thus the probability to be 1 is
$1 - (1-\frac{1}{n})^{k*S}$</li>
</ul>


<p>Because
$\lim\limits_{n \rightarrow \infty}(1+\frac{1}{n})^{n} = e,$ then we will have
$$ 1 - (1-\frac{1}{n})^{k*S} = 1-(1-\frac{1}{n})^{\frac{k*n}{c}}&lt;1-e^{\frac{-k}{c}},$$</p>

<p>which means the probability to be
$1 &lt; 1 - e^{\frac{-k}{c}}.$ For a new object, the probability of all bits having been set as
$ 1 &lt; (1 - e^{\frac{-k}{c}})^{k}.$</p>

<p>To minimize $ (1 - e^{\frac{-k}{c}})^{k},$
enlarge c as much as possible
when $k = \ln(2) * c,$ it will be minimized.</p>

<h2>Implementation</h2>

<p>A good implementation can be found at <a href="https://github.com/MagnusS/Java-BloomFilter/blob/master/src/com/skjegstad/utils/BloomFilter.java">here</a>.</p>

    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-bloom-filter/">more &rarr;</a>
        </div>
    </div>
</div>


<div class="page-pagination">
    <ul class="pagination">
        <li><span>Navi:</span></li>
    
    
    
    
            
    
        <li><a href="/">newest</a></li>
    
    
        <li><a href="/page7">&larr;</a></li>
    
    
    
        <li><a class="disabled">...</a></li>
    
    
    
    
        <li><a href="/page3">3</a></li>
    
    
    
    
    
        <li><a href="/page4">4</a></li>
    
    
    
    
    
        <li><a href="/page5">5</a></li>
    
    
    
    
    
        <li><a href="/page6">6</a></li>
    
    
    
    
    
        <li><a href="/page7">7</a></li>
    
    
    
    
    
        <li><a href="/page8" class="active">8</a></li>
    
    
    
    
    
    <!--  -->

    <!--  -->
    <li><a href="/page8">oldest</a></li>
    <li><span>149</span></li>
    </ul>
</div>

     </div>
     <div class="page-footer">
         <span>
             Powered by <a href="https://github.com/mojombo/jekyll">Jekyll</a>
             | Hosted by <a href="http://github.com">Github.com</a>
             | <span class="page-generator-time">11/03/2014 </span>
         </span>
     </div>
     </div>
     <script src="/static/js/bootstrap.js" type="text/javascript"></script>
     <script src="/static/google-code-prettify/prettify.js" type="text/javascript"></script>
     <script type="text/javascript">
        $(document).ready(function() {
            $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto');
            prettyPrint();
        });
     </script>
     <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56332595-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>
