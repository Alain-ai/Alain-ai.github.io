<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Alain's Blog | Home - Java, Python, Machine Learning, LeetCode</title>
    <meta name="keywords" content="Java, Python, Machine Learning, LeetCode">
    <meta name="description" content="The personal site of Alain, MLer and programmer. I write about Java, Python, Machine Learning and my code on LeetCode Here.">
    <meta name="author" content="Alain">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="/static/favicon.ico" rel="shortcut icon">
    <link href="/static/css/bootstrap.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/css/font-awesome.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/google-code-prettify/prettify.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/css/application.css" rel="stylesheet" type="text/css" media="all">
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

</head>
<body>
     <div class="page-container">
     <div class="page-heading">
         <div class="page-brand">
             <h1><a href="/">Alain</a></h1>
             <h2><a href="/tags.html">Java Intermediate, Python Beginner, Machine Learning Fan</a></h2>

         </div>
         <div class="page-navbar">
             <div class="page-navbar-container">
                 <ul class="page-nav">
                     <li><a href="/">Home</a></li>
                     <!-- <li><a href="/about.html">About</a></li> -->
                     <li><a href="/categories.html">Categories</a></li>
                     <li><a href="/tags.html">Tags</a></li>
                     <li><a href="/archive.html">Archives</a></li>
                 </ul>
             </div>
         </div>
     </div>
     <div class="page-article">
         <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56332595-1', 'auto');
  ga('send', 'pageview');

</script>



<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-binary-tree-maximum-path-sum/">LeetCode | Binary Tree Maximum Path Sum in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-binary-tree-maximum-path-sum/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a binary tree, find the maximum path sum. The path may start and end at any node in the tree.

Algorithm:
    1. "maxPathSum_rec(node)" returns the path with maximal sum which starts at "node"
    2. "max_local" is the maximal sum of the path which passes by a specific node
    3. we would like to find the max of all "max_local"s among all nodes
'''


class Solution:
    # @param root, a tree node
    # @return an integer
    def maxPathSum(self, root):
        res = [-(1<<31)]
        self.maxPathSum_rec(root, res)
        return res[0]

    def maxPathSum_rec(self, root, res):
        if not root:
            return 0
        max_left = self.maxPathSum_rec(root.left, res)
        max_right = self.maxPathSum_rec(root.right, res)
        max_local = max(max_left, 0) + max(max_right, 0) + root.val
        res[0] = max(res[0], max_local)
        return max(max_left, max_right, 0) + root.val
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-binary-tree-maximum-path-sum/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-two-sum/">LeetCode | Two Sum in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-two-sum/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:
    Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution.

Algorithm:
    use a map to store what is expected
'''


class Solution:
    # @return a tuple, (index1, index2)
    def twoSum(self, num, target):
        i = 0
        cMap = {}
        while i < len(num):
            if target - num[i] in cMap.keys():
                return (cMap[target-num[i]] + 1, i + 1)
            else:
                cMap[num[i]] = i
            i += 1
        return (0, 0)
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-two-sum/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-remove-nth-node-from-end-of-list/">LeetCode | Remove Nth Node From End of List in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-remove-nth-node-from-end-of-list/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a linked list, remove the nth node from the end of list and return its head.

Algorithm:
    corner case would be n <= 0 or n > len, but we don\'t have to consider corner cases this time since n is good here

Note:
    1. Given n will always be valid.
    2. Try to do this in one pass.
'''


class Solution:
    # @return a ListNode
    def removeNthFromEnd(self, head, n):
        p = head
        for i in xrange(1, n):
            p = p.next
        dummy = ListNode(0)
        dummy.next = head
        pp = dummy
        while p.next:
            p = p.next
            pp = pp.next
        if pp.next:
            pp.next = pp.next.next
        else:
            pp.next = None
        return dummy.next
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-remove-nth-node-from-end-of-list/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-next-permutation/">LeetCode | Next Permutation in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-next-permutation/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory.



Algorithm:
    ...
'''


class Solution:
    # @param num, a list of integer
    # @return a list of integer
    def nextPermutation(self, num):
        for i in xrange(len(num) - 2, -1, -1):
            for j in xrange(len(num) - 1, i, -1):
                if num[i] < num[j]:
                    num[i], num[j] = num[j], num[i]
                    num[i+1:] = num[i+1:][::-1]
                    return num
        return num[::-1]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-next-permutation/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-merge-two-sorted-lists/">LeetCode | Merge Two Sorted Lists in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-merge-two-sorted-lists/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Algorithm:
    straightforward
'''


class Solution:
    # @param two ListNodes
    # @return a ListNode
    def mergeTwoLists(self, l1, l2):
        p = dummy = ListNode(0)
        p1, p2 = l1, l2
        while p1 and p2:
            if p1.val <= p2.val:
                p.next = p1
                p1 = p1.next
            else:
                p.next = p2
                p2 = p2.next
            p = p.next
        if p1:
            p.next = p1
        if p2:
            p.next = p2
        return dummy.next
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-merge-two-sorted-lists/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-jump-game-ii/">LeetCode | Jump Game II in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-jump-game-ii/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Implement pow(x, n).

Algorithm:
    Recursion
    1. n < 0
    2. n == 0
    3. n is odd
    4. n is even
'''


class Solution:
    # @param x, a float
    # @param n, a integer
    # @return a float
    def pow(self, x, n):
        if n == 0:
            return 1.
        if n < 0:
            return 1. / self.pow(x, -n)
        y = self.pow(x, n/2)
        if n & 1:
            return y * y * x
        else:
            return y * y
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-jump-game-ii/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-jump-game/">LeetCode | Jump Game in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-jump-game/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.

    For example:
    Given array A = [2,3,1,1,4]

    The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

Algorithm:
    Greedy
'''


class Solution:
    # @param A, a list of integers
    # @return an integer
    def jump(self, arr):
        if len(arr) <= 1:
            return 0
        head = arr[0]
        i = 1
        cnt = 1
        while head < len(arr) - 1:
            cnt += 1
            max_head = 0
            while i <= head:
                max_head = max(max_head, arr[i] + i)
                i += 1
            i = head + 1
            head = max_head
        return cnt
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-jump-game/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-generate-parentheses/">LeetCode | Generate Parentheses in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-generate-parentheses/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

Algorithm:
    DFS
'''


class Solution:
    # @param an integer
    # @return a list of string
    def generateParenthesis(self, n):
        res = []
        self.generateParenthesis_rec(n, n, res, '')
        return res
        
    def generateParenthesis_rec(self, l, r, res, tmp):
        if r < l:
            return
        elif r == l == 0:
            res.append(tmp)
        else:
            if l:
                self.generateParenthesis_rec(l-1, r, res, tmp+'(')
            if r:
                self.generateParenthesis_rec(l, r-1, res, tmp+')')
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-generate-parentheses/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-count-and-say/">LeetCode | Count and Say in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-count-and-say/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    The count-and-say sequence is the sequence of integers beginning as follows:

    1, 11, 21, 1211, 111221, ...
    1 is read off as "one 1" or 11.
    11 is read off as "two 1s" or 21.
    21 is read off as "one 2, then one 1" or 1211.
    Given an integer n, generate the nth sequence.

Note:
    The sequence of integers will be represented as a string.

Algorithm:
    straightforward
'''


class Solution:
    # @return a string
    def countAndSay(self, n):
        # corner case: n == 1
        if n == 1:
            return '1'
        res = [1]
        for i in xrange(1, n):
            cnt, num = 1, res[0]
            tmp = []
            for j in xrange(1, len(res)):
                if res[j] == res[j-1]:
                    cnt += 1
                else:
                    tmp += [cnt, num]
                    cnt, num = 1, res[j]
            tmp += [cnt, num]
            res = tmp
        return ''.join([str(itr) for itr in res])
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-count-and-say/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-zigzag-conversion/">LeetCode | ZigZag Conversion in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-zigzag-conversion/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

    P   A   H   N
    A P L S I I G
    Y   I   R
    And then read line by line: "PAHNAPLSIIGYIR"

Algorithm:
    follow the zig-zag manner
'''


class Solution:
    # @return a string
    def convert(self, s, nRows):
        if nRows == 1:
            return s
        nCol = (nRows - 1) * ((len(s) / (2 * nRows - 2)) + 1)
        mat = [[None for j in xrange(nCol)] for i in xrange(nRows)]
        r, c, idx = 0, 0, 0
        for unit in xrange(((len(s) / (2 * nRows - 2)) + 1)):
            for i in xrange(nRows - 1):
                if idx >= len(s):
                    return ''.join(mat[i][j] if mat[i][j] else '' for i in xrange(nRows) for j in xrange(nCol))
                mat[r][c] = s[idx]
                r, idx = r + 1, idx + 1
            for i in xrange(nRows - 1):
                if idx >= len(s):
                    return ''.join(mat[i][j] if mat[i][j] else '' for i in xrange(nRows) for j in xrange(nCol))
                mat[r][c] = s[idx]
                r, c, idx = r - 1, c + 1, idx + 1
        return ''.join(mat[i][j] if mat[i][j] else '' for i in xrange(nRows) for j in xrange(nCol))
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-zigzag-conversion/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-word-search/">LeetCode | Word Search in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-word-search/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Algorithm:
    BFS
'''


class Solution:
    # @param board, a list of lists of 1 length string
    # @param word, a string
    # @return a boolean
    def exist(self, board, word):
        if len(board) == 0:
            return len(word) == 0
        m, n = len(board), len(board[0])
        visited = [[False for itr in xrange(n)] for itr2 in xrange(m)]
        for i in xrange(m):
            for j in xrange(n):
                if self.exist_rec(board, word, 0, i, j, visited):
                    return True
        return False

    def exist_rec(self, board, word, level, row, col, visited):
        if level == len(word):
            return True
        else:
            m, n = len(board), len(board[0])
            if 0 <= row <= m and 0 <= col <= n and board[row][col] == word[level] and not visited[row][col]:
                visited[row][col] = True
                if self.exist_rec(board, word, level+1, row-1, col, visited):
                    return True
                if self.exist_rec(board, word, level+1, row+1, col, visited):
                    return True
                if self.exist_rec(board, word, level+1, row, col-1, visited):
                    return True
                if self.exist_rec(board, word, level+1, row, col+1, visited):
                    return True
                visited[row][col] = False
            else:
                return False
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-word-search/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-valid-sudoku/">LeetCode | Valid Sudoku in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-valid-sudoku/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Determine if a Sudoku is valid, according to Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ".".

Algorithm:
    DFS
    in "grids", we just use the ith row to flag the ith 3*3 grid
'''


class Solution:
    # @param board, a 9x9 2D array
    # @return a boolean
    def isValidSudoku(self, board):
        rows = [[False for itr1 in xrange(9)] for itr2 in xrange(9)]
        cols = [[False for itr1 in xrange(9)] for itr2 in xrange(9)]
        grids = [[False for itr1 in xrange(9)] for itr2 in xrange(9)]
        for i in xrange(9):
            for j in xrange(9):
                if board[i][j] == '.':
                    continue
                num = int(board[i][j]) - 1
                if rows[i][num] or cols[j][num] or grids[(i/3)*3+(j/3)][num]:
                    return False
                else:
                    rows[i][num], cols[j][num], grids[(i/3)*3+(j/3)][num] = True, True, True
        return True
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-valid-sudoku/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-valid-palindrome/">LeetCode | Valid Palindrome in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-valid-palindrome/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example,
    1. "A man, a plan, a canal: Panama" is a palindrome.
    2. "race a car" is not a palindrome.

Algorithm:
    squeeze to the middle from two ends and ignore all alphanumeric characters
'''


class Solution:
    # @param s, a string
    # @return a boolean
    def isPalindrome(self, s):
        i, j = 0, len(s) - 1
        while i < j:
            if ord('a') <= ord(s[i].lower()) <= ord('z') or ord('0') <= ord(s[i]) <= ord('9'):
                if ord('a') <= ord(s[j].lower()) <= ord('z') or ord('0') <= ord(s[j]) <= ord('9'):
                    if s[i].lower() == s[j].lower():
                        i, j = i + 1, j - 1
                    else:
                        return False
                else:
                    j -= 1
            else:
                i += 1
        return True
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-valid-palindrome/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-unique-binary-search-trees/">LeetCode | Unique Binary Search Trees in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-unique-binary-search-trees/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given n, how many structurally unique BST\'s (binary search trees) that store values 1...n?

Algorithm:
    DP
    DP[i] = sum(DP[j] * DP[i-1-j]) over j from 0 to i-1
'''


class Solution:
    # @return an integer
    def numTrees(self, n):
        DP = [1, 1] + [0 for i in xrange(n-1)]
        for i in xrange(2, n+1):
            for j in xrange(i):
                k = i - j - 1
                DP[i] += DP[j] * DP[k]
        return DP[-1]
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-unique-binary-search-trees/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-triangle/">LeetCode | Triangle in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-triangle/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character '.'. You may assume that there will be only one unique solution.

Algorithm:
    DFS
'''


class Solution:
    # @param board, a 9x9 2D array
    # Solve the Sudoku by modifying the input board in-place.
    # Do not return any value.
    def solveSudoku(self, board):
        rows = [[False for itr1 in xrange(9)] for itr2 in xrange(9)]
        cols = [[False for itr1 in xrange(9)] for itr2 in xrange(9)]
        grids = [[False for itr1 in xrange(9)] for itr2 in xrange(9)]
        for i in xrange(9):
            for j in xrange(9):
                if board[i][j] != '.':
                    idx = int(board[i][j]) - 1
                    rows[i][idx], cols[j][idx], grids[3*(i/3)+(j/3)][idx] = True, True, True
        return self.solveSudoku_rec(board, rows, cols, grids, 0)

    def solveSudoku_rec(self, board, rows, cols, grids, level):
        if level == 81:
            return True
        i, j = level / 9, level % 9
        if board[i][j] != '.':
            return self.solveSudoku_rec(board, rows, cols, grids, level+1)
        for k in xrange(1, 10):
            idx = k - 1
            if rows[i][idx] or cols[j][idx] or grids[3*(i/3)+(j/3)][idx]:
                continue
            rows[i][idx], cols[j][idx], grids[3*(i/3)+(j/3)][idx] = True, True, True
            succ = self.solveSudoku_rec(board, rows, cols, grids, level+1)
            if not succ:
                rows[i][idx], cols[j][idx], grids[3*(i/3)+(j/3)][idx] = False, False, False
            else:
                return succ
        return False
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-triangle/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-trapping-rain-water/">LeetCode | Trapping Rain Water in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-trapping-rain-water/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

Algorithm:
    the amount of water trapped at bar i is affected by the highest bars on the left and right
    denote them as "height_i", "high_left", "high_right"
    the amount of water can be hold at bar i is min(high_left, high_right) - height_i
'''


class Solution:
    # @param A, a list of integers
    # @return an integer
    def trap(self, A):
        # corner case:
        # 1. len(A) <= 2
        # 2. same heights for all bars
        max_from_left = [0 for itr in xrange(len(A))]
        max_left = 0
        for i in xrange(len(A)-1, -1, -1):
            if A[i] > max_left:
                max_left = A[i]
            max_from_left[i] = max_left
        max_from_right = [0 for itr in xrange(len(A))]
        max_right = 0
        for i in xrange(len(A)):
            if A[i] > max_right:
                max_right = A[i]
            max_from_right[i] = max_right
        return sum(map(lambda x: min(x[0], x[1]) - x[2], zip(max_from_left, max_from_right, A)))
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-trapping-rain-water/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-symmetric-tree/">LeetCode | Symmetric Tree in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-symmetric-tree/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

Algorithm:
    DFS
    "isSymmetric_rec(left, right)" returns True when left and its subtree is the same as right and its subtree
'''


class Solution:
    # @param root, a tree node
    # @return a boolean
    def isSymmetric(self, root):
        if not root:
            return False
        return self.isSymmetric_rec(root.left, root.right)

    def isSymmetric_rec(self, left, right):
        if left == right is None:
            return True
        elif left is None or right is None:
            return False
        elif left.val == right.val:
            return self.isSymmetric_rec(left.left, right.right) and self.isSymmetric_rec(left.right, right.left)
        else:
            return False
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-symmetric-tree/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-swap-nodes-in-pairs/">LeetCode | Swap Nodes in Pairs in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-swap-nodes-in-pairs/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    Given a linked list, swap every two adjacent nodes and return its head.

Algorithm:
    ...
'''


class Solution:
    # @param a ListNode
    # @return a ListNode
    def swapPairs(self, head):
        dummy = ListNode(0)
        dummy.next, p = head, dummy
        while p.next and p.next.next:
            p1, p2 = p.next, p.next.next
            p.next = p2
            p1.next = p2.next
            p2.next = p1
            p = p1
        return dummy.next
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-swap-nodes-in-pairs/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-substring-with-concatenation-of-all-words/">LeetCode | Substring with Concatenation of All Words in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-substring-with-concatenation-of-all-words/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.

Algorithm:
    ...

Note:
    can not get accepted sigh
'''


class Solution:
    # @param S, a string
    # @param L, a list of string
    # @return a list of integer
    def findSubstring(self, S, L):
        res = []
        if len(S) == 0 or len(L) == 0:
            return res
        len_S = len(S)
        len_L = len(L)
        len_T = len(L[0]) * len_L
        res = []
        req = dict()
        for itr in L:
            req[itr] = req.get(itr, 0) + 1
        for i in xrange(len_S - len_T):
            S1 = S[i:i+len_T]
            j = 0
            req_local = dict(req)
            while j < len_L:
                s = S1[j*len(L[0]):(j+1) * len(L[0])]
                if s not in req_local or req_local[s] <= 0:
                    break
                req_local[s] -= 1
                j += 1
            if j == len_L:
                res.append(i)
        return res
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-substring-with-concatenation-of-all-words/">more &rarr;</a>
        </div>
    </div>
</div>

<div class="page-content">
    <div class="post-heading">
        <a href="/markdown-leetcode-string-to-integer-atoi/">LeetCode | String to Integer (atoi) in Python</a>
    </div>
    <div class="post-meta">
        <!-- <span>
            date:
            <a href="/markdown-leetcode-string-to-integer-atoi/">10/2014</a>
        </span> -->
        <!-- <span><i class="fa fa-ellipsis-v"></i></span> -->
        <span>
            category:
            
            <a href="/categories.html#leetcode-ref">leetcode</a>
            
        </span>
        <span><i class="fa fa-ellipsis-v"></i></span>
        <span>
            tag:
            
            <a href="/tags.html#Python-ref">Python</a>
            
        <span>
    </div>
    <div class="post-entry">
        <!-- import js for mathjax -->


<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>




<pre>
'''
Question:
    There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Algorithm:
    be careful about input cases

Note:
    1. starting with minus or plus sign
    2. starting with 0
    3. contain non-digit char
        1. beginning or middle
        2. end
        3. white space anywhere
    4. overflow?
'''


class Solution:
    # @return an integer
    def atoi(self, s):
        s = s.strip()
        if len(s) == 0:
            return 0
        minus = False
        if s[0] == '+':
            s = s[1:]
        elif s[0] == '-':
            s = s[1:]
            minus = True
        num = 0
        s = list(s)
        for i in xrange(len(s)):
            if not ('0' <= s[-1] <= '9'):
                s.pop()
            else:
                break
        s = ''.join(s)
        for i in xrange(len(s)):
            if ord('0') <= ord(s[i]) <= ord('9'):
                num = num * 10 + (ord(s[i]) - ord('0'))
            else:
                break
        if minus:
            if num > 2**31:
                return -(2**31)
            else:
                return -num
        else:
            if num > 2**31 - 1:
                return 2 ** 31 - 1
            else:
                return num
</pre>


    </div>
    <div class="post-footer">
        <div class="read-more">
            <a href="/markdown-leetcode-string-to-integer-atoi/">more &rarr;</a>
        </div>
    </div>
</div>


<div class="page-pagination">
    <ul class="pagination">
        <li><span>Navi:</span></li>
    
    
    
            
    
    
            
    
        <li><a href="/">newest</a></li>
    
    
        <li><a href="/page3">&larr;</a></li>
    
    
    
    
    
        
        <li><a href="/">1</a></li>
        
    
    
    
    
        <li><a href="/page2">2</a></li>
    
    
    
    
    
        <li><a href="/page3">3</a></li>
    
    
    
    
    
        <li><a href="/page4" class="active">4</a></li>
    
    
    
    
    
        <li><a href="/page5">5</a></li>
    
    
    
    
    
        <li><a href="/page6">6</a></li>
    
    
    
    
    
        <li><a href="/page7">7</a></li>
    
    
    
    
    
        <li><a href="/page8">8</a></li>
    
    
    
    
    
        <li><a class="next" href="/page5">&rarr;</a></li>
    
    <!--  -->

    <!--  -->
    <li><a href="/page8">oldest</a></li>
    <li><span>149</span></li>
    </ul>
</div>

     </div>
     <div class="page-footer">
         <span>
             Powered by <a href="https://github.com/mojombo/jekyll">Jekyll</a>
             | Hosted by <a href="http://github.com">Github.com</a>
             | <span class="page-generator-time">11/03/2014 </span>
         </span>
     </div>
     </div>
     <script src="/static/js/bootstrap.js" type="text/javascript"></script>
     <script src="/static/google-code-prettify/prettify.js" type="text/javascript"></script>
     <script type="text/javascript">
        $(document).ready(function() {
            $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto');
            prettyPrint();
        });
     </script>
     <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56332595-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>
